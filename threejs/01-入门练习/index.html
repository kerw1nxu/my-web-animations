<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js å…¥é—¨ - æ—‹è½¬ç«‹æ–¹ä½“</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">
        ğŸ”§ é“å‹ææè´¨<br>
        HDRI ç¯å¢ƒå…‰ç…§ | é“¶ç™½è‰²é‡‘å±<br>
        metalness: 0.95 | roughness: 0.35<br>
        é¼ æ ‡æ‹–åŠ¨æ—‹è½¬è§†è§’ | æ»šè½®ç¼©æ”¾
    </div>

    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ RGBELoader ç”¨äºåŠ è½½ HDRI -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>

    <script>
        // åœºæ™¯
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // ç›¸æœº
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = 5;

        // æ¸²æŸ“å™¨ - å¯ç”¨ç‰©ç†æ­£ç¡®å…‰ç…§
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // åˆ›å»ºç«‹æ–¹ä½“
        const geometry = new THREE.BoxGeometry(2, 2, 2);

        // é“å‹ææè´¨å‚æ•°
        const material = new THREE.MeshStandardMaterial({
            color: 0xe8e8e8,        // é“å‹æé“¶ç™½è‰²
            metalness: 0.95,        // é«˜é‡‘å±åº¦
            roughness: 0.35,        // è½»å¾®ç£¨ç ‚æ„Ÿï¼ˆé“å‹æè¡¨é¢ï¼‰
            envMapIntensity: 1.2    // å¢å¼ºç¯å¢ƒåå°„
        });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        // æ·»åŠ è¾¹æ¡† - æ¨¡æ‹Ÿé“å‹æè¾¹ç¼˜
        const edges = new THREE.EdgesGeometry(geometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 2 });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        cube.add(wireframe);

        // åŠ è½½ HDRI ç¯å¢ƒè´´å›¾
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        new THREE.RGBELoader()
            .setDataType(THREE.UnsignedByteType)
            .load('empty_warehouse_01_4k.hdr', function(texture) {
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;

                // è®¾ç½®åœºæ™¯ç¯å¢ƒ
                scene.environment = envMap;
                scene.background = new THREE.Color(0x2a2a2a); // æ·±ç°èƒŒæ™¯è¡¬æ‰˜é‡‘å±

                texture.dispose();
                pmremGenerator.dispose();

                // HDRI åŠ è½½å®Œæˆåå¼€å§‹åŠ¨ç”»
                animate();
            });

        // è¾…åŠ©ç¯å…‰ï¼ˆHDRI æ˜¯ä¸»å…‰æºï¼Œè¿™äº›åªæ˜¯è¡¥å……ï¼‰
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);

        // é¼ æ ‡äº¤äº’
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', () => isDragging = true);
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };

                cube.rotation.y += deltaMove.x * 0.01;
                cube.rotation.x += deltaMove.y * 0.01;
            }
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });

        // æ»šè½®ç¼©æ”¾
        document.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(2, Math.min(10, camera.position.z));
        });

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // è‡ªåŠ¨æ—‹è½¬å±•ç¤ºåå°„æ•ˆæœ
            cube.rotation.x += 0.003;
            cube.rotation.y += 0.005;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>